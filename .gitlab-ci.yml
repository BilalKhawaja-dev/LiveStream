# GitLab CI/CD Pipeline for Terraform
# This pipeline validates, plans, and deploys Terraform infrastructure

stages:
  - validate
  - security
  - plan
  - deploy
  - test

variables:
  TF_VERSION: "1.6.0"
  AWS_DEFAULT_REGION: "eu-west-2"
  PROJECT_NAME: "streaming-logs"
  TF_ROOT: ${CI_PROJECT_DIR}
  TF_ADDRESS: ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/${CI_COMMIT_REF_SLUG}

cache:
  key: "${TF_ROOT}"
  paths:
    - ${TF_ROOT}/.terraform
    - ${TF_ROOT}/.terraform.lock.hcl

before_script:
  - cd ${TF_ROOT}
  - apk add --no-cache curl jq
  - curl -fsSL https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip -o terraform.zip
  - unzip terraform.zip && rm terraform.zip
  - mv terraform /usr/local/bin/
  - terraform --version

# Validation Stage
terraform:validate:
  stage: validate
  image: alpine:latest
  script:
    - terraform fmt -check -recursive
    - terraform init -backend=false
    - terraform validate
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

terraform:lint:
  stage: validate
  image: alpine:latest
  before_script:
    - cd ${TF_ROOT}
    - apk add --no-cache curl
    - curl -s https://raw.githubusercontent.com/terraform-linters/tflint/master/install_linux.sh | bash
  script:
    - tflint --init
    - tflint --format json > tflint-results.json
  artifacts:
    reports:
      junit: tflint-results.json
    paths:
      - tflint-results.json
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

# Security Stage
terraform:security:
  stage: security
  image: alpine:latest
  before_script:
    - cd ${TF_ROOT}
    - apk add --no-cache curl
    - curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash
  script:
    - tfsec . --format json --out tfsec-results.json
    - tfsec . --format junit --out tfsec-junit.xml
  artifacts:
    reports:
      junit: tfsec-junit.xml
    paths:
      - tfsec-results.json
      - tfsec-junit.xml
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

checkov:security:
  stage: security
  image: bridgecrew/checkov:latest
  script:
    - checkov -d . --framework terraform --output json --output-file checkov-results.json
    - checkov -d . --framework terraform --output junit --output-file checkov-junit.xml
  artifacts:
    reports:
      junit: checkov-junit.xml
    paths:
      - checkov-results.json
      - checkov-junit.xml
    expire_in: 1 week
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"

# Plan Stage
.terraform_plan_template: &terraform_plan
  stage: plan
  image: alpine:latest
  before_script:
    - cd ${TF_ROOT}
    - apk add --no-cache curl jq aws-cli
    - curl -fsSL https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip -o terraform.zip
    - unzip terraform.zip && rm terraform.zip
    - mv terraform /usr/local/bin/
    - aws sts get-caller-identity
  script:
    - terraform init
    - terraform workspace select ${ENVIRONMENT} || terraform workspace new ${ENVIRONMENT}
    - cp environments/${ENVIRONMENT}/terraform.tfvars terraform.tfvars
    - terraform plan -var-file=terraform.tfvars -out=${ENVIRONMENT}.tfplan
    - terraform show -json ${ENVIRONMENT}.tfplan > ${ENVIRONMENT}-plan.json
  artifacts:
    paths:
      - ${ENVIRONMENT}.tfplan
      - ${ENVIRONMENT}-plan.json
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_PIPELINE_SOURCE == "web"

terraform:plan:dev:
  <<: *terraform_plan
  variables:
    ENVIRONMENT: "dev"
  environment:
    name: dev

terraform:plan:staging:
  <<: *terraform_plan
  variables:
    ENVIRONMENT: "staging"
  environment:
    name: staging

terraform:plan:prod:
  <<: *terraform_plan
  variables:
    ENVIRONMENT: "prod"
  environment:
    name: prod
  rules:
    - if: $CI_PIPELINE_SOURCE == "web"
      when: manual
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual

# Deploy Stage
.terraform_apply_template: &terraform_apply
  stage: deploy
  image: alpine:latest
  before_script:
    - cd ${TF_ROOT}
    - apk add --no-cache curl jq aws-cli
    - curl -fsSL https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip -o terraform.zip
    - unzip terraform.zip && rm terraform.zip
    - mv terraform /usr/local/bin/
    - aws sts get-caller-identity
  script:
    - terraform init
    - terraform workspace select ${ENVIRONMENT}
    - terraform apply -auto-approve ${ENVIRONMENT}.tfplan
  artifacts:
    paths:
      - terraform.tfstate
    expire_in: 1 week

terraform:deploy:dev:
  <<: *terraform_apply
  variables:
    ENVIRONMENT: "dev"
  environment:
    name: dev
    url: https://console.aws.amazon.com/cloudwatch/home?region=eu-west-2#dashboards
  dependencies:
    - terraform:plan:dev
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "web"
      when: manual

terraform:deploy:staging:
  <<: *terraform_apply
  variables:
    ENVIRONMENT: "staging"
  environment:
    name: staging
    url: https://console.aws.amazon.com/cloudwatch/home?region=eu-west-2#dashboards
  dependencies:
    - terraform:plan:staging
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "web"
      when: manual

terraform:deploy:prod:
  <<: *terraform_apply
  variables:
    ENVIRONMENT: "prod"
  environment:
    name: prod
    url: https://console.aws.amazon.com/cloudwatch/home?region=eu-west-2#dashboards
  dependencies:
    - terraform:plan:prod
  rules:
    - if: $CI_PIPELINE_SOURCE == "web"
      when: manual
  before_script:
    - cd ${TF_ROOT}
    - apk add --no-cache curl jq aws-cli
    - curl -fsSL https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip -o terraform.zip
    - unzip terraform.zip && rm terraform.zip
    - mv terraform /usr/local/bin/
    - aws sts get-caller-identity
    - echo "⚠️  PRODUCTION DEPLOYMENT - Please review the plan before proceeding"
    - echo "Plan file: ${ENVIRONMENT}.tfplan"

# Test Stage
.terraform_test_template: &terraform_test
  stage: test
  image: alpine:latest
  before_script:
    - cd ${TF_ROOT}
    - apk add --no-cache curl jq aws-cli bash
    - curl -fsSL https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip -o terraform.zip
    - unzip terraform.zip && rm terraform.zip
    - mv terraform /usr/local/bin/
    - chmod +x scripts/validate-terraform.sh
  script:
    - ./scripts/validate-terraform.sh test --environment ${ENVIRONMENT}
  artifacts:
    reports:
      junit: test-results-${ENVIRONMENT}.xml
    paths:
      - test-results-${ENVIRONMENT}.xml
    expire_in: 1 week

terraform:test:dev:
  <<: *terraform_test
  variables:
    ENVIRONMENT: "dev"
  dependencies:
    - terraform:deploy:dev
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "web"
      when: manual

terraform:test:staging:
  <<: *terraform_test
  variables:
    ENVIRONMENT: "staging"
  dependencies:
    - terraform:deploy:staging
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "web"
      when: manual

terraform:test:prod:
  <<: *terraform_test
  variables:
    ENVIRONMENT: "prod"
  dependencies:
    - terraform:deploy:prod
  rules:
    - if: $CI_PIPELINE_SOURCE == "web"
      when: manual

# Cost Estimation (for merge requests)
infracost:
  stage: plan
  image: infracost/infracost:ci-0.10
  before_script:
    - cd ${TF_ROOT}
  script:
    - infracost breakdown --path . --format json --out-file infracost-base.json
    - infracost output --path infracost-base.json --format table
  artifacts:
    paths:
      - infracost-base.json
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Cleanup job for failed deployments
cleanup:failed:
  stage: deploy
  image: alpine:latest
  before_script:
    - cd ${TF_ROOT}
    - apk add --no-cache curl jq aws-cli
    - curl -fsSL https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip -o terraform.zip
    - unzip terraform.zip && rm terraform.zip
    - mv terraform /usr/local/bin/
  script:
    - echo "Cleaning up failed deployment resources..."
    - terraform init
    - terraform workspace select ${ENVIRONMENT} || true
    - terraform refresh || true
    - echo "Manual cleanup may be required for environment: ${ENVIRONMENT}"
  rules:
    - if: $CI_PIPELINE_SOURCE == "web"
      when: manual
  variables:
    ENVIRONMENT: "dev"  # Default to dev for safety

# Documentation generation
docs:generate:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
    - curl -Lo terraform-docs.tar.gz https://github.com/terraform-docs/terraform-docs/releases/download/v0.16.0/terraform-docs-v0.16.0-linux-amd64.tar.gz
    - tar -xzf terraform-docs.tar.gz
    - chmod +x terraform-docs
    - mv terraform-docs /usr/local/bin/
  script:
    - terraform-docs markdown table --output-file README.md .
    - terraform-docs markdown table --output-file modules/README.md modules/
  artifacts:
    paths:
      - README.md
      - modules/README.md
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"
      changes:
        - "*.tf"
        - "modules/**/*.tf"